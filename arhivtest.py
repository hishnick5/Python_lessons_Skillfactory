'''
"""
приоритет арифметических операций:
1) операции в скобках ( )
2) возведение в степень '**'
3) Создание отрицательного числа, смена знака '+,-'
4) Умножение и деление '* /'
5) Целочисленное деление 'div' '//'
6) Остаток от деления или 
деление по модулю 'mod' '%'
7) Сложение и вычитание '+,-'
"""

# PYTHON-4. Циклы. Задание 4.8
# Напишите код, который определяет, является ли
# вложенный список test_matrix квадратной матрицей
# (то есть матрицей, у которой количество строк
# равно количеству столбцов).
test_matrix = [
    [1, 2, 3],
    [7, -1, 2],
    [123, 2, -1],
    [123, 5, 1]
]
is_square = None
if len(test_matrix) == len(test_matrix[0]):
    is_square=True
else:
    is_square=False
print(is_square)
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Циклы. ЗАДАНИЕ 5.3 
# информация о динамике пользователей user_dynamics
# Ваша задача — переписать код так, чтобы он
# работал с помощью функции enumerate(). Таким образом,
# вам необходимо создать цикл по индексам и
# элементам списка user_dynamics
user_dynamics = [-5, 2, 4, 8, 12, -7, 5] 
for i, value in enumerate(user_dynamics):
    if value < 0:
        print(f'Day {i+1} : {value}')
-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON 4. Циклы. Задание 5.4
# Дан список, состоящий из строк. Список хранится в переменной str_list.
# Создайте новый список cut_str_list.
# В цикле добавляйте в список cut_str_list списки, состоящие из порядкового
# номера строки из списка str_list (номер в рамках данной задачи начинается с 0)
# и трёх первых символов из каждой строки. Если длина строки меньше трёх символов,
# то добавляется вся строка целиком.
str_list = ['Hello', 'my', 'name', 'is', 'Ezeikel', 'I', 'like', 'knitting']
cut_str_list = []
for number, value in enumerate(str_list):
    cut_str_list.append([number, value[0:3]])
print(cut_str_list)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Циклы. Задание 5.10
# Дан словарь mixture_dict. Значения в нём могут быть трёх типов: 
# строки (str) или числа (int и float).
# Посчитайте, сколько значений в словаре mixture_dict являются числами.
# Результат занесите в переменную count_numbers.
# Используйте в своём коде оператор continue.
mixture_dict = {'key1': 24, 'key2': '1.4', 'key3': 14, 'key4': 16.24, 'key6': 124.2414, 'key7': 12.2}
count_numbers = 0
for i in mixture_dict:
    if type(mixture_dict[i]) is str:
        continue
    else:
        count_numbers += 1
print(count_numbers)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Циклы. Задание 5.11
# Дана переменная text, в которой содержится текст. 
# В этом тексте могут присутствовать знаки препинания:
# точки ('.'), запятые(','), точки с запятой (';'), 
# вопросительные ('?') и восклицательные знаки ('!'), а также тире ('—').
# count_punctuation, ключами которого являются знаки препинания,
# а значениями — их количество в тексте.
# если какого-то из шести указанных знаков препинания нет в тексте,
# то в итоговом словаре значение, 
# соответствующее этому знаку препинания,должно быть равно 0
text = """
Иной раз казалось ему, что он уже с месяц лежит; 
в другой раз — что всё тот же день идет. Но об том — об том 
он совершенно забыл; зато ежеминутно помнил, что об чем-то забыл, 
чего нельзя забывать, — терзался, мучился, припоминая, стонал, 
впадал в бешенство или в ужасный, невыносимый страх. 
Тогда он порывался с места, хотел бежать, но всегда кто-нибудь 
его останавливал силой, и он опять впадал в бессилие и беспамятство. 
Наконец он совсем пришел в себя!
"""
count_punctuation = {'!': 0, ',': 0, '-': 0, '.': 0, ';': 0, '?': 0}
symbol_list = ['.', ',', ';', '?', '!', '-']
text = text.lower()
text = text.replace(' ', '')
text = text.replace('\n', '')
for symbol in text:
    if symbol in symbol_list:
        count_punctuation[symbol] += 1
print(count_punctuation)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Циклы. Задание 5.13
# Напишите программу для подсчёта количества вхождений заданного символа
# в каждую из строк этого списка. Искомый символ хранится
# в переменной symbol_to_check.
# Для подсчёта используйте словарь: в качестве ключа запишите в него
# строку, в качестве значения — число вхождений искомого символа в эту
# строку. Для хранения словаря используйте переменную с именем word_dict.
str_list = ["text", "morning", "notepad", "television", "ornament"]
symbol_to_check = 't'
word_dict = {}
for word in str_list:
    word_dict[word] = 0
    if symbol_to_check in word:
        for symbol in word:
            if symbol == symbol_to_check:
                word_dict[word] += 1
print(word_dict)
-/-/-/-/-/-/-/-/-/-/-/-

-/-/-/-/-/-/-/-/-/-/-/-
description = 'Male, 39 years old, born on November 27, 1979'
description_split = description.split(',')
gender = description_split[0].lower()
age = description_split[1].split()[0]
data = description_split[2].split()[3]
year = description_split[3]
full_data = f'Пол: {gender}, возраст: {age}, день рождения: {data}, год рождения: {year}'
print(full_data)
-/-/-/-/-/-/-/-/-/-/-/-
a = list(range(1, 11))
# получаем 4 последних элемента списка
b = a[-4:]
print(b)
-/-/-/-/-/-/-/-/-/-/-/-
# способы создания словарей
# с помощью 'dict' используя список кортежей состоящих из пары значений
ddd = dict([(1, 1), (2, 4)])
# с помощью 'dict' используя ключ без кавычек, равно значение в кавычках
dd = dict(short='dict', long='dictionary')
# с помощью 'dict.fromkeys' передавая списком несколько
#  ключей с одинаковым значением или без него если надо без ", 100"
d = dict.fromkeys(['Katya', 'Lena'], 100)
# с помощью генераторов словарей, которые очень похожи на генераторы списков
dddd = {a: a ** 2 for a in range(7)}
dictionary = {(1, 2.0): 'кортежи могут быть ключами',
              1: 'целые числа могут быть ключами',
              'бежать': 'строки тоже',
              ['носок', 1, 2.0]: 'а списки не могут'}
-/-/-/-/-/-/-/-/-/-/-/-
# Метод get() возвращает значение по указанному ключу в параметрах. 
# Название ключа всегда должно быть уникальным. В случае обращения по несуществующему ключу,
# Python вернет значение None. С помощью метода get(), можно проверять, есть ли такой ключ
# в словаре. И если есть, то мы получим значение по ключу.

first_count = {
    14: 'четырнадцать',
    15: 'пятнадцать',
    16: 'шестнадцать'
}
print(first_count.get(15))
# пятнадцать // выведет на экран
-/-/-/-/-/-/-/-/-/-/-/-
# функция для сортировки словаря по значениям ключа
def best_student(**name):
    # создаем переменную в которую будем заносить 
    # отсортированный по возрастанию список значений ключей словаря
    result = sorted(name, key=name.get)
    # и возвращаем первый (минимальный) элемент из списка
    return result[0]
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-5.2. Продвинутое использование функций в Python
# 3/10  3. Изменение переменных вне области видимости
# Внешняя функция для вычисления итоговой стоимости
def calculate_cost(cost, sale):
    # Внутренняя функция для предобработки аргумента sale
    def preprocessing_sale():
        # Объявляем, что используем нелокальную переменную sale
        nonlocal sale
        # Если sale — строка
        if type(sale) is str:
            # Удаляем из строки '%', приводим к float и делим на 100
            sale = float(sale.replace('%', '')) / 100
        # Если sale — целое число
        elif type(sale) is int:
            # Делим его на 100 
            sale = sale / 100
    # Запускаем предобработку, прежде чем вычислить стоимость
    preprocessing_sale()
    # Считаем итоговую стоимость и возвращаем её
    # (стоимость — стоимость * скидка)     
    return cost - cost * sale
print(calculate_cost(1330, '15%'))
print(calculate_cost(1330, 15))
print(calculate_cost(1330, 0.15))
-/-/-/-/-/-/-/-/-/-/-/-
# Посмотреть список встроенных имён можно с помощью следующей команды.
# (обратите внимание на два символа нижнего подчёркивания справа и слева 
# от ключевого слова builtins):
# print(dir(__builtins__))
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-5.2. Продвинутое использование функций в Python
# 3/10  3. Изменение переменных вне области видимости
# Задание 3.7 (External resource)
advertising_campaigns = {'ютуб': [212, 248], 'вк': [514, 342], 'радио': [339, 125]}
# Очень крутой код для вычисления максимума из нескольких значений у ключа из словаря
# Создаём новый пустой словарь  
advertising_campaigns_max = {}  
# Создаём цикл по ключам исходного словаря  
for key in advertising_campaigns:  
    # Вычисляем максимум в списке, лежащем по ключу key  
    max_efect = max(advertising_campaigns[key])  
    # Добавляем максимум в новый словарь  
    advertising_campaigns_max[key] = max_efect
print(advertising_campaigns_max)
-/-/-/-/-/-/-/-/-/-/-/-
dictionary = {'марафон': 'гонка бегунов длиной около 26 миль',
                'персона': 'человек',
                'бежал': 'бежать в прошедшем времени',
                'бежать': 'двигаться со скоростью',
                'туфля': 'род обуви, закрывающей ногу не выше щиколотки',
                'туфли': 'туфля во множественном числе'}
# В примере кода ниже цикл for использует метод items() для
# получения пары «ключ — значение» на каждую итерацию.
for key, value in dictionary.items():
    print(key, '-', value)
-/-/-/-/-/-/-/-/-/-/-/-
# Метод setdefault() в Python является встроенным методом словаря и используется
# для возврата значения ключа, если он уже существует в словаре. Если ключ не существует, 
# метод устанавливает значение по умолчанию и возвращает его.
# dictionary.setdefault(keyname, value)
# Здесь keyname — это ключ, который мы ищем в словаре, а value — это значение, которое 
# будет установлено по умолчанию, если ключ не найден в словаре. Аргумент value является необязательным.
# Если он не указан, значение по умолчанию будет None.
friends = {"Kolya": 180, "Marina": 176, "Dima": 201, "Yana": 183, "Nina": 156, "Stas":183, "Nastya": 163}
friends.setdefault("Nastya", 100)
friends.setdefault("Alyona", 170)
friends.setdefault("Nelly")
# В следующем примере мы создаем словарь, где ключи — это первые буквы слов,
# а значения — это списки слов, начинающиеся с соответствующей буквы.
words = ["apple", "banana", "cherry", "date", "elderberry", "fig", "grape", "kiwi"]
d = {}
for slovo in words:
    key = slovo[0]
    d.setdefault(key, []).append(slovo)
#print(d)
# Метод setdefault() также может быть полезен для подсчета элементов в списке. 
# В следующем примере мы подсчитываем, сколько раз каждое слово появляется в списке.
spisok_slov = ["apple", "banana", "apple", "cherry", "banana", "banana"]
noviy_slovar = {}
for slovo in spisok_slov:
    noviy_slovar.setdefault(slovo, 0)
    noviy_slovar[slovo] += 1
print(noviy_slovar)
-/-/-/-/-/-/-/-/-/-/-/-
# Методы множеств
s1 = set('hello')
s2 = set(['w', 'o', 'w'])
result1 = s1.union(s2) # Объединение
result2 = s1.intersection(s2) # Пересечение
result3 = s1.difference(s2) # Вычитание из 1-го, элементы 2-го
print(result1, result2, result3)
-/-/-/-/-/-/-/-/-/-/-/-
# Проверка високосного года
year = 1900
year_is_leap = (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0)
print(year_is_leap)
-/-/-/-/-/-/-/-/-/-/-/-
# Отломить дольку от шоколадки
n, m, k = 15, 16, 45
result = (k % n == 0 or k % m == 0) and (k <= n * m)
print(result)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. Задание 3.7
# С помощью метода словарей get() и проверки на None реализуйте условие,  которое проверяет,
# есть ли в истории прихода накладная с указанным в переменной invoice_number номером.
# Результатом работы условия должна стать булева переменная со значением 'True' или 'False'
arrival_of_goods = {
    '148902': {
        'Футболка с принтом': 180,
        'Свитшот черный': 245,
        'Джинсы серые': 252
    },
    '893516': {
        'Футболка с принтом': 43,
        'Свитшот черный': 64,
        'Джинсы черные': 102
    },
    '893481': {
        'Кружка керамическая': 35,
        'Свитшот черный': 10,
        'Джинсы сервые': 14
    }
}

invoice_number = '148902'
invoice_exists = arrival_of_goods.get(invoice_number) is not None
print(invoice_exists)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. тернарные операторы
# сравнение двух чисел и получения большего из них:
a = 42
b = 41
result = a if a > b else b
print(result)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. Задание 5.5
player_1 = 'бумага'
player_2 = 'ножницы'
wind_list = ['камень', 'ножницы', 'бумага']
if player_1 == player_2:
    print('Ничья!')
elif player_1 in wind_list[0] and player_2 in wind_list[1]:
    print('Первый игрок — победитель!')
elif player_1 in wind_list[1] and player_2 in wind_list[0]:
    print('Второй игрок — победитель!')
elif player_1 in wind_list[0] and player_2 in wind_list[2]:
    print('Второй игрок — победитель!')
elif player_1 in wind_list[2] and player_2 in wind_list[0]:
    print('Первый игрок — победитель!')
elif player_1 in wind_list[1] and player_2 in wind_list[2]:
    print('Первый игрок — победитель!')
elif player_1 in wind_list[2] and player_2 in wind_list[1]:
    print('Второй игрок — победитель!')
else:
    print('Вы ввели неверные данные ((')
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. 
dish_time_dict = {
    'Рамен с говядиной': 15,
    'Суши': 18,
    'Лагман с курицей': 20,
    'Лагман с говядиной': 24,
    'Плов с курицей': 28
    }
street_time_dict  = {
    'Дзержинский': 39,
    'Солнечный': 40,
    'Заводской': 27,
    'Гагаринский': 43,
    'Кировский': 37,
    'Октябрьский': 34
    }
dish, street = 'Плов с курицей', 'Гагаринский'
if street not in street_time_dict:
    # Неизвестный район
    print('Извините, Доставка в ваш район недоступна')
elif dish not in dish_time_dict:
    # Неизвестное блюдо
    print('Извините, Блюдо недоступно, закажите что-то другое')
else:
    dish_time = dish_time_dict[dish] # время приготовления блюда
    street_time = street_time_dict[street] # время доставки
    full_time = dish_time + street_time # общее время доставки
    delay = full_time - 60 # время задержки
    if delay <=0:
        # Если задержка не положительна
        print('Доставка будет осуществелена вовремя')
    else: # Иначе 
        print(f'Курьер задержится на {delay} минут')
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. ЗАДАЧА №6
написать программу на Python, которая будет проверять ваш пароль на надёжность.
Длина – 8 символов (если меньше – то проще взломать, а если длиннее – то сложно запомнить).
Пароль не должен состоять только из цифр.
Пароль не должен состоять только из букв.
В пароле должны быть заглавные буквы.
В пароле должны быть строчные символы.
В пароле должен быть хотя бы один из специальных символов ('*', '-', '#'), 
но каждый из символов должен входить в пароль не более 1 раза.
Вот список «плохих» символов: '!', '@', '$', '%', '^', '`', '&', '(', ')', '+', '=', '_', '~'.
В случае надёжного пароля программа должна выводить фразу «Пароль идеален!», 
а в остальных случаях будут перечислены все ошибки, которые вы допустили.

errors_dict = {
    'length': 'Длина пароля не равна 8 символам',
    'digits': 'Пароль состоит только из цифр',
    'letters': 'Пароль состоит только из букв',
    'upper': 'Отсутствуют заглавные буквы',
    'lower': 'Отсутствуют строчные буквы',
    'spec': 'Отсутствуют спецсимволы в пароле',
    'bad_symbols': 'В пароле использованы непредусмотренные символы'
}
bad_symbols = ['!', '@', '$', '%', '^', '`', '&', '(', ')', '+', '=', '_', '~']
password = 'Aafaf*al'
if len(password) == 8:
    errors_dict.pop('length')
if not password.isdigit():
    errors_dict.pop('digits')
if not password.isalpha():
    errors_dict.pop('letters')
if password.upper() != password:
    errors_dict.pop('lower')
if password.lower() != password:
    errors_dict.pop('upper')
if '*' in password or '-' in password or '#' in password:
    errors_dict.pop('spec')
    if password.count('*') > 1 or password.count('-') > 1 or password.count('#') > 1:
        errors_dict['spec_count'] = 'Какой-то из спецсимволов в пароле использован более одного раза'
if len(set(password).intersection(set(bad_symbols))) == 0:
    errors_dict.pop('bad_symbols')
if len(errors_dict) > 0:
    print(list(errors_dict.values()))
else:
    print('Пароль идеален!')
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. Задание 5.6
# Обдумывая акцию для распродажи, владелец компании пришёл к выводу,
# что продавать все кроссовки по акции на сайте компании невыгодно. 
# Поэтому была придумана новая схема: если клиент покупает одновременно кроссовки двух разных брендов,
# то его общая скидка составит 5 %, если две пары от одного бренда — то 10 %.
# Для упрощения задачи будем считать, что покупатель в любом случае купит не более двух пар кроссовок.
# Список товаров в корзине хранится в переменной purchases и может быть пустым.
# Также будем считать, что для всех товаров бренда действует одна и та же цена. 
# Расценки товаров хранятся в словаре prices:
purchases = ["Nike", "Nike"]
prices = {'Adidas': 4298, 'Nike': 6550, 'Puma': 4490, 'Asics': 3879}
if not purchases:
    print('Ваша корзина пуста')
elif len(set(purchases)) == 1:
    purchases_sum = prices.get(purchases[0]) + prices.get(purchases[1])
    discount = purchases_sum - (purchases_sum * 0.1)
    print(f'Стоимость заказа составила: {purchases_sum}. С учетом скидки в 10% — {discount}')
else:
    purchases_sum = prices.get(purchases[0]) + prices.get(purchases[1])
    discount = purchases_sum - (purchases_sum * 0.05)
    print(f'Стоимость заказа составила: {purchases_sum}. С учетом скидки в 5% — {discount}')
------------------------------
prices = {'Adidas': 4298, 'Nike': 6550, 'Puma': 4490, 'Asics': 3879}
# Проверяем, что корзина не пустая
if purchases:
    # Проверяем, что в корзине 1 товар
    if len(purchases) == 1:
        # Достаем значение по ключу и определяем стоимость
        cost = prices[purchases[0]]
        print(f"Стоимость заказа составила: {cost}")
    # Проверяем, что в корзине 2 товара
    elif len(purchases) == 2:
        # Проверяем, что товары одинаковых брендов
        if len(set(purchases)) == 1:
            discount = 10
        else:
            discount = 5
        # Достаем значение по ключам и определяем стоимость
        cost = prices[purchases[0]] + prices[purchases[1]] 
        # Рассчитываем стоимость с учетом скидки
        discount_cost = cost * (1 - discount/100) 
        print(f"Стоимость заказа составила: {cost}. С учетом скидки в {discount}% — {discount_cost}")
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. Задание 5.7
# Мы распределяем резюме по категориям:
# Категория 1 — резюме, обновленные в мае 2019
# Категория 2 — резюме, обновленные в период с января по май (не включая май) 2019 года
# Категория 3 — резюме, составленные раньше, чем 1 января 2019 года
# Напишите программу, которая определяет категорию резюме. 
# Категорию занесите целым числом в переменную category.
# date = '16.04.2019 15:59'
# date = '12.05.2019 08:42'
# date = '05.07.2018 20:15'

split_time = date.split(' ')[0]
split_date = split_time.split('.')
category = None
if split_date[1] == '05' and split_date[2] == '2019':
    category = 1
elif split_date[1] in ['01', '02', '03', '04'] and split_date[2] == '2019':
    category = 2
else:
    category = 3
print(category)
---------------------------------
# Разделяем строку на части по пробелу и берем первую из них
day_month_year = date.split(' ')[0]
# Разделяем строку по символу '.' и создаем соответствующие переменные
day, month, year = day_month_year.split('.')
# Проверяем, что резюме обновлено в 2019 году
if year == '2019':
    # Проверяем, что резюме обновлено в мае
    if month == '05':
        # Присваиваем 1-ую категорию
        category = 1
    else:
        # Присваиваем 2-ую категорию
        category = 2
else:
    # Присваиваем 3-ью категорию
    category = 3
print(category)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы.
city_info = "Москва , не готов к переезду , готов к командировкам"
#city_info = "Москва , м. Беломорская , не готов к переезду, не готов к командировкам"
#city_info = "Санкт-Петербург , готов к переезду (Сочи, Москва) , готов к командировкам"
#city_info = "Новосибирск , готов к переезду, не готов к командировкам"

million_cities = ['Новосибирск', 'Екатеринбург', 'Нижний Новгород', 'Казань', 
                  'Челябинск', 'Омск', 'Самара', 'Ростов-на-Дону', 'Уфа', 
                  'Красноярск', 'Пермь', 'Воронеж', 'Волгоград'
                  ]

temp_city = city_info.split(' , ')[0]
if temp_city == 'Москва' or temp_city == 'Санкт-Петербург':
    city = temp_city
elif temp_city in million_cities:
    city = 'Город миллионник'
else:
    city = 'Другое'
print(city)
-/-/-/-/-/-/-/-/-/-/-/-
medicines = {'Ибупрофен': 99, 'Эспумизан': 279, 'Пенталгин': 119}
name = 'Ибупрофен'
try:
    temp = medicines[name]
except KeyError as e:
    print(f'Такого ключа в словаре нет {e}')
else:
    print(temp)
-/-/-/-/-/-/-/-/-/-/-/-
# Добавляем конструкцию try-except для отлова нашей ошибки
try:
    age = int(input("How old are you?"))
    # Проверяем, что возраст пользователя корректный
    if age > 100 or age <= 0:
        # Намеренно вызываем ошибку, в скобках указываем текст ошибки
        raise ValueError("You are too old or don't exist") 
# Ловим исключение ValueError
except ValueError as e:
    # В случае возникновения исключения выводим сообщение
    print(f"Wrong age: {e}")
# В блоке else прописываем часть, которая выполняется, если блок try отработал без ошибок
else:
    # Возраст выводится только в том случае, если пользователь ввёл правильный возраст. 
    print("You are {} years old!".format(age))
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-3. Условные операторы. 6. Исключения. Задание 6.7
number = 0
try: # Добавляем конструкцию try-except для отлова нашей ошибки
    if not number: # Если переменная равно нулю(если она не истина, 'не True')
        # Намеренно вызываем ошибку, в скобках указываем текст ошибки
        raise ZeroDivisionError('Вы собираетесь делить на 0')
# Ловим исключение ZeroDivisionError
except ZeroDivisionError as e:
    print(e) # В случае возникновения исключения выводим сообщение
else:
    # Но если ошибки не произошло
    result = round(10 / number, 3)
    print(result)
print(result)
-----------------------
number = 0
try: # Добавляем конструкцию 'try-except' для отлова нашей ошибки
    if not number: # Если переменная равна нулю(если она не истина, 'не True')
        # Намеренно вызываем ошибку, в скобках указываем текст ошибки
        raise ZeroDivisionError('Вы собираетесь делить на 0')
# Ловим исключение ZeroDivisionError
except ZeroDivisionError as e:
    result = e # В случае возникновения исключения выводим сообщение
else:
    # Но если ошибки не произошло и 'number' не равна нулю тогда
    result = round(10 / number, 3)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Циклы. 3/10  2. Цикл for. ЗАДАЧА №4
places = [
    'Red Square',
    'Swallow Nest',
    'Niagara Falls',
    'Grand Canyon',
    'Louvre',
    'Hermitage'
]
location = {
    'Red Square': 'Russia',
    'Swallow Nest': 'Russia',
    'Niagara Falls': 'USA',
    'Grand Canyon': 'USA',
    'Louvre': 'France',
    'Hermitage': 'Russia'
}
for i in places: # не верный метод и не рабочий!
    country = location[i] 
    if country != 'Russia': 
        i = 'Unavailable'
print(places)

N = len(places) # Вычисляем длину списка
# Создаём цикл по списку мест, которые хотим посетить.
# i — текущее значение последовательности
for i in range(N):
    # places[i] — i-й элемент в списке places
    # Получаем страну из словаря location по ключу
    # заносим значение ключа словаря по индексу списка
    country = location[places[i]]
    if country != 'Russia': # Сравниваем название стран
        places[i] = 'Unavailable' # Помечаем место как недоступное
print(places) # Выводим результирующий список
---------------------------------------------
# Если внутри тела цикла for не предполагается изменение списка, 
по которому проходят итерации, предпочтительнее использовать цикл по элементам списка, 
т. е. итерируемый объект — сам список. Примеры: вывод содержимого списка на экран, 
сложение элементов списка, подсчёт элементов по условию (подсчитать, сколько в списке чисел, 
а сколько строк), передача элементов списка в сторонние функции (отправка сообщений по почте).
# Если вы заранее знаете, что внутри тела функции будете изменять список, 
то цикл ведётся по индексам списка. Цикл по индексам может вестись в случаях, 
когда в вычислениях участвует не один элемент списка, а сразу несколько.
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Цикл 'for'. Задание 2.12 
word_list = ["My", "name", "is", "Sergei", "EOS", "I'm", "from", "Moscow", "EOS"]
# Создаём накопительную переменную, в которую будем добавлять слова
text = ''
# Создаём цикл по словам из списка word_list
for word in word_list:
    # Проверяем, что слово - не является обозначением конца предложения
    if word != 'EOS':
        # Если условие выполняется, добавляем к текущему предложению слово и пробел
        text += word + ' '
    else:
        # В противном случае (слово - обозначение конца предложения),
        # отрезаем последний пробел слева, добавляем точку и пробел справа
        text = text[:-1] + '.' + ' '
# После объединения текста удаляем лишние пробелы слева и справа
text = text.strip()
print(text)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Математический выравнивающий курс
Упростите выражение -3a-7+(-6a)+1, и запишите в ответ получившийся результат, не используя пробелы, скобки и знаки умножения.
-3a-7+(-6a)+1
-3a-6a-7+1 # значения с "а" ставим рядом
-(3a+6a)+(7-1) # -на-даёт+, -на+даёт нам -, но разрядность сохраняется
-9a-6 #
-/-/-/-/-/-/-/-
Выберите верный результат упрощения выражения 4(-15-3а)+4(-а-5).
как сдесь получается -16a-80 ?
упращаем так:
4(-15-3а)+4(-а-5): # 4 умножаем на каждое в скобках и не забываем что -на+ даёт нам минус
4*-15-4*3a+4*-a-4*5= #
-60-12a-4a-20= #
-16a-80 #
-/-/-/-/-/-/-/-/-/-/-/-
# НОД-наибольшее общее делимое (36;84)=12
# 36= 2*2*3*3
# 84= 2*2*3*7
# берём те которые присутствуют и там и там
# 2*2*3=12
# НОК-наименьшее общее кратное (15;18;24)=360
# 15= 3*5
# 18= 2*3*3
# 24= 2*2*2*3
# берём те которые не-повторяются
# 3*5*2*3*2*2=(5*2)*((3*3)*2*2)=10*9*2*2=360
# Тема. Дроби.
# сравнение дробей
# 1/3 и 2/7
# Нахождение общего знаменателя двух или более дробей — это умножение знаменателей друг на друга:
# Также в качестве общего знаменателя можно брать наименьшее общее кратное (НОК).
# Однако в нашем случае НОК для 3 и 7 также будет равен 21.
# первое число 1/3 (21 делим на 3=7, значит числитель и знаменатель умножаем на 7) 1/3==7/21
# второе число 2/7 (21 делим на 7=3, значит числитель и знаменатель умножаем на 3) 2/7==6/21
# Ответ: 7/21 > 6/21
# Сложение дробей
# Если у дробей разные знаменатели, дроби сначала необходимо привести к общему знаменателю, 
# а затем сложить их числители:
# 4/15 + 3/5 (НОК=15) 15 / 15 = 1, 15 / 5 = 3, Значит 4/15*1=4/15, 3/5*3=9/15
# Итого: 4/15 + 9/15 = 13/15
# Вычитание дробей происходит по тому же принципу, что и сложение. 
# Из числителя одной дроби вычитается числитель другой, а знаменатель остаётся прежним:
# В случае с разными знаменателями всё происходит аналогично, но первоначально, 
# разумеется, необходимо привести дроби к общему знаменателю:
# 10/15 - 3/5 = (НОК=15) 15 / 15 = 1, 15 / 5 = 3, Значит 10/15*1=10/15, 3/5*3=9/15
# Итого 10/15 - 9/15 = 1/15
# При умножении дробей отдельно перемножаются числители и отдельно — знаменатели.
# Важно, что для умножения приводить дроби к общему знаменателю не требуется 
# (это не повлияет на результат, но усложнит вычисления):
# 3/5 * 4/7 = (3*4)/(5*7) = 12/35
# Чтобы разделить одну дробь на другую, необходимо перевернуть вторую дробь 
# (поменять местами числитель и знаменатель), а затем просто умножить первую на перевёрнутую вторую:
# 3/5 : 4/7 = 3/5 * 7/4 = 21/20 = 1|1/20
# Если числитель и знаменатель можно разделить на одно и то же число, дробь можно сократить. 
# Например, для дроби 10/15 мы можем и числитель, и знаменатель разделить на 5: 
# 10/15 == 2/3
# Кроме изученных ранее типов дробей, существует ещё один — десятичные дроби.
# Это дроби, у которых знаменатель кратен 10 (равен 10, 100, 1000 и т. д.) 
# и которые записываются определённым образом. К примеру, 3/4 можно записать в десятичном виде 
# как 0.75. Если мы захотим представить в десятичном виде дробь 7/25, то можем преобразовать 
# её в дробь со знаменателем, кратным 10 (для этого домножим числитель и знаменатель дроби на 4),
# и получить 28/100, что можно записать как 0.28. Количество знаков после запятой равняется 
# количеству нулей в знаменателе числа. Пример: 3/4 = 12/16 == 0.75 (Десятичная дробь)
-/-/-/-/-/-/-/-/-/-/-/-
# Если мы вычитаем отрицательное число, это эквивалентно сложению с положительным:
# 5-(-4)==5+4=9
# Если мы перемножаем два отрицательных числа, в результате получается положительное число
# (-8)*(-3)=24
# Если мы делим одно отрицательное число на другое отрицательное число,
# в результате мы также получаем положительное число:
# (-24):(-4)=6
# Задание 7.2
# Найдите значение выражения (-4)*(-5)+(-3)*6-(-9)
# (-4)*(-5)|+|(-3)*6|-(-9) # умножаем -4 * -5 и получаем положительное число =20
# 20+|(-3)*6|-(-9) # -3*6 -на+ даёт-, разрядность остаётся отрицательной
# 20+(-18)|-(-9) # 20+(-18)==20-18=2 и получаем положительное число, +на- дает минус
# 2-(-9) # 2-(-9)==2+9 и получаем положительное число, -на- доёт нам + 
# = 11 
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON 4, Циклы, 4. Работа с вложенными циклами. подсчёт количества символов в тексте
str_list = ['text', 'morning', 'notepad', 'television', 'ornament']
count = 0
for text in str_list:
    count += text.count('e')
print(count)
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Циклы. 5/10  4. Работа с вложенными циклами. ЗАДАЧА №4
student_scores = [
    [56, 90, 80],
    [80, 86, 92],
    [91, 76, 89],
    [91, 42, 60],
    [65, 30, 90]
]
N = len(student_scores)
M = len(student_scores[0])
summa = 0
math_sum = 0
info_sum = 0
rus_sum = 0
for i in range(N):
    math_sum += student_scores[i][0]
    info_sum += student_scores[i][1]
    rus_sum += student_scores[i][2]
    for j in range(M):
        summa += student_scores[i][j]
print('Средний балл по математике:', math_sum/N)
print('Средний балл по информатике:', info_sum/N)
print('Средний балл по русскому:', rus_sum/N)
print('Средний балл по всем экзаменам:', round(summa/(N*M), 1))
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-4. Циклы. 5/10  4. Работа с вложенными циклами. *Задание 4.10
# Напишите программу, которая вычисляет средние значения удовлетворённости клиентов за каждый месяц
# (среднее значение в каждом из вложенных списков), округлённые до двух знаков после точки-разделителя,
# а также максимальное из этих средних значений.
# Средняя удовлетворённость по месяцам должна быть представлена в виде списка month_satisfaction.
# Максимальная удовлетворённость должна быть представлена в виде float-числа
# и записана в переменную max_satisfaction.
customer_satisfaction = [
    [0.87, 0.56, 0.77],
    [0.22, 0.46, 0.56, 0.89, 0.95],
    [0.45, 0.44, 0.68],
    [0.73, 0.88, 0.95, 0.49]
]
month_satisfaction = []
max_satisfaction = 0
for i in customer_satisfaction:
    row = 0
    count = 0
    for j in i:
        row += j
        count += 1
    summ = round((row / count), 2)
    month_satisfaction.append(summ)    

for i in month_satisfaction:
    if i > max_satisfaction:
        max_satisfaction = i
-/-/-/-/-/-/-/-/-/-/-/-
def matrix_sum(matrix1, matrix2):
    new_matrix = []
    if len(matrix1) == len(matrix2) and len(matrix1[0]) == len(matrix2[0]):
        for i in range(len(matrix1)):
            elems = []
            for j in range(len(matrix1[0])):
                elem = matrix1[i][j] + matrix2[i][j]
                elems.append(elem)
            new_matrix.append(elems)
    else:
        print("Error! Matrices dimensions are different!")
        return None
    return new_matrix
-/-/-/-/-/-/-/-/-/-/-/-

-/-/-/-/-/-/-/-/-/-/-/-
def root(value, n=2):
    result = value ** (1/n)
    return result
new_list = ['bbb', 'ababa','aaa', 'aaaaa',  'cc']
def get_length(line):
    return len(line)
new_list.sort(key=get_length)
print(new_line)
-/-/-/-/-/-/-/-/-
# напишем лямбда-функцию, для получения корня произвольной степени от числа
nth_root = lambda num, n: num**(1/n)
# Чтобы воспользоваться этой функцией, можно написать, например:
print(nth_root(16,4))
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# напишем lambda-функцию, которая определяет, является ли число чётным
# Напоминание: оператор % используется для получения остатка
# от деления. Если остаток от деления на 2 равен 0, то
# число является чётным.
# Обратный слэш (\) используется в Python для того,
# чтобы перенести одну строку кода на следующую строку.
# Получается, что компьютер интерпретирует записанное ниже
# как одну строку.
is_even = lambda num: "even" if num % 2 == 0 \
    else "odd"
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Вот lambda-функция, которая принимает на вход переменное число 
# порядковых аргументов и возвращает кортеж из них:
func_args = lambda *args: args
print(func_args(1,4,6,7))
# Будет напечатано:
# (1, 4, 6, 7)
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# функция, которая определяет, делится ли число на 2 или на 3
scary_func = lambda num: 'divided by 2 and 3' \
    if num % 6 == 0 \
    else 'divided by 2' if num % 2 == 0 \
    else 'divided by 3' if num % 3 == 0 \
    else 'not divided by 2 nor 3'
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Мы хотим отсортировать слова в списке не по алфавиту, а по их длине
names = ['Ivan', 'Kim', 'German', 'Margarita', 'Simon']
names.sort()
print(names)
# Будет напечатано:
# ['German', 'Ivan', 'Kim', 'Margarita', 'Simon']

# представим, что мы хотим отсортировать слова в списке не по алфавиту, а по их длине
names.sort(key=lambda name: len(name))
print(names)
# Будет напечатано:
# ['Kim', 'Ivan', 'Simon', 'German', 'Margarita']

# отсортируем этот список с помощью lambda-функции, которая возвращает кортеж, 
# где в качестве первого значения указана длина слова, а в качестве второго-само слово:
new_list.sort(key=lambda word: (len(word), word))
print(new_list)
# Будет напечатано:
# ['cc', 'aaa', 'bbb', 'aaaaa', 'ababa']
-/-/-/-/-/-/-/-/-/-/-/-/-/-
hyp = lambda a, b: (a**2+b**2)**(1/2)
print(hyp(3,4))
print(hyp(1,9))
-/-/-/-/-/-/-/-/-/-/-/
def sort_sides(l_in):
    l_in.sort(key=lambda a: (a[0]**2+a[1]**2)**(1/2))
    return l_in
print(sort_sides([(3,4), (1,2), (10,10)]))
-/-/-/-/-/-/-/-/-/-/-/-

# PYTHON-5.1. Введение в функции в Python. 8/11  7. Закрепление знаний. 
# Задание 7.17 (External resource). 
# Напишите функцию sort_ignore_case(ls), которая принимает на вход список ls
# и сортирует его без учёта регистра по алфавиту. Функция возвращает отсортированный список.
def sort_ignore_case(ls):
    ls.sort(key=lambda x: x.lower())
    return ls
print(sort_ignore_case(['Acc', 'abc']))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
def get_min_string(s1, s2):
    def get_count_unique_symbols(s):
        s = s.lower()
        s = s.replace(' ', '')
        s = len(set(s))
        return s
    s1_len = get_count_unique_symbols(s1)
    s2_len = get_count_unique_symbols(s2)
    if s1_len < s2_len:
        return s1
    elif s2_len < s1_len:
        return s2
    else:
        return s1, s2
print(get_min_string(s1='школа', s2='school'))
-/-/-/-/-/-
def cash(less_money):
    global money
    money -= less_money
    return money
money = 200000
print(cash(1000))
-/-/-/-/-/-/-/-/-/-
# Словарь с курсами валют (по отношению к рублю)
currencies = {'USD': 74, 'EUR': 88, 'GBP': 98 , 'CHF': 82}
# Общее количество денег на счету, которое нужно конвертировать
money = 100000
# Функция для конвертации валюты, аргумент - наименование валюты
def convert(currency):
    result = money / currencies[currency]
    return result
money = convert('USD')
# Вызываем функцию для конвертации валюты
print(money)
-/-/-/-/-/-/-/-/-/-/-/-
# Словарь с курсами валют (по отношению к рублю)
currencies = {'USD': 74, 'EUR': 88, 'GBP': 98 , 'CHF': 82}
# Общее количество денег на счету, которое нужно конвертировать
money = 100000
# Функция для конвертации валюты, аргумент - наименование валюты
def convert(currencies, money, currency):
    result = money / currencies[currency]
    return result
convert_money = convert(currencies, money, 'EUR')  
print(convert_money)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
def calculate_cost(cost, sale):
    def preprocessing_sale():
        nonlocal sale
        if type(sale) is str:
            sale = float(sale.replace('%', '')) / 100
        elif type(sale) is int:
            sale = sale / 100
        elif type(sale) is float:
            sale = sale / 100
        else:
            raise ValueError("Некорректный формат скидки")
        
    preprocessing_sale()
    return cost - cost * sale
print(calculate_cost(1330, [2,3,6]))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
advertising_campaigns = {'ютуб': [212, 248], 'вк': [514, 342], 'радио': [339, 125]}
# Создаём новый пустой словарь  
advertising_campaigns_max = {}  
# Создаём цикл по ключам исходного словаря  
for key in advertising_campaigns:  
    # Вычисляем максимум в списке, лежащем по ключу key  
    max_elem = max(advertising_campaigns[key])  
    # Добавляем максимум в новый словарь  
    advertising_campaigns_max[key] = max_elem
print(advertising_campaigns_max)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
def is_leap(year):
        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
            return True
        else:
            return False
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
def check_date(day, month, year):

    def is_leap(year):
        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
            return True
        else:
            return False
        
    if (type(day) is not int) or (type(month) is not int) or (type(year) is not int):
        return False
    if (year <= 1900) or (year >= 2023):
        return False
    if (month < 1) or (month > 12):
        return False
    if (day < 1) or (day > 31):
        return False
    if (month in [4,6,9,11]) and (day > 30):
        return False
    if month == 2 and day > 29 and is_leap(year) == True:
        return False
    if month == 2 and day > 28 and is_leap(year) != True:
        return False
    return True
-/-/-/-/-/-/-/--/-/-//-/-/-/-/--/-/-/-
# Функция для проверки корректности даты
def check_date(day, month, year):
    # Создадим функцию проверки високосного года
    def is_leap(year):
        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
            return True
        else:
            return False
    # Проверяем день, месяц и год на целочисленность
    if (type(day) is not int) or (type(month) is not int) or (type(year) is not int):
        return False
    # Проверяем год на заданный диапазон
    if (year <= 1900) or (year >= 2022):
        return False
    # Проверяем месяц на заданный диапазон     
    if (month < 1) or (month > 12):
        return False
    # Проверяем день на заданный диапазон  
    if (day < 1) or (day > 31): 
        return False
    # Проверяем апрель, июнь, сентябрь и ноябрь на количество дней
    if (month in [4,6,9,11]) and (day > 30):
        return False
    # Проверяем количество дней в феврале с проверкой високосного года
    if month == 2 and day > 29 and is_leap(year) == True:
        return False
    if month == 2 and day > 28 and is_leap(year) != True:
        return False
    return True

# Функция для регистрации пользователей
def register(surname, name, date, middle_name=None, registry=None):
    # Вспомогательная функция для предобработки даты
    def preprocessing_date(date):
        # Разделяем строку по символу точки
        day, month, year = date.split('.')
        # Преобразуем все данные к типу данных int
        day, month, year = int(day), int(month), int(year)
        if check_date(day, month, year) is not True:
            raise ValueError("Invalid Date!")
        return day, month, year
    # Если список не был передан — создаём пустой список
    if registry is None:
        registry = list()
    # Разделяем дату на составляющие
    day, month, year = preprocessing_date(date)
    # Добавляем данные в список
    registry.append((surname, name, middle_name, day, month, year))
    return registry

reg = register('Petrova', 'Maria', '13.03.2003', 'Ivanovna')
reg = register('Ivanov', 'Sergej', '24.09.1995', registry=reg)
reg = register('Smith', 'John', '29.02.2000', registry=reg)
print(reg)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Функция для вычисления наличия треугольника
def check_exist_triangle(a, b, c):
    if (a + b > c) and (a + c > b) and (b + c > a):
        return True
    else:
        return False

# Функция для вычисления сторон треугольника
def triangle(p1, p2, p3):
    # По умолчанию параметры функции берутся из объемлющей области видимости
    def sides(p1, p2, p3):
        # Распаковываем кортежи для удобства, “;” означает новую строку кода
        x1, y1 = p1; x2, y2 = p2; x3, y3 = p3
        # Вычисляем стороны по теореме Пифагора
        a = ((x2 - x1) ** 2 + (y2 - y1)** 2) ** 0.5
        b = ((x3 - x1) ** 2 + (y3 - y1)** 2) ** 0.5
        c = ((x3 - x2) ** 2 + (y3 - y2)** 2) ** 0.5
        return a, b, c

    # Функция для вычисления периметра треугольника
    def calculate_perimeter_triangle(a, b, c):
        # Периметр — сумма всех сторон треугольника
        perimeter = a + b + c
        return perimeter

    # Функция для вычисления площади треугольника
    def calculate_area_triangle(a, b, c):
        # Вычисляем полупериметр 
        # Значение perimeter берётся из объемлющей области видимости
        p = perimeter / 2
        # Вычисляем площадь по формуле Герона
        area = (p * (p - a) * (p - b) * (p - c)) ** 0.5
        return area
    a, b, c = sides(p1, p2, p3)
    if check_exist_triangle(a, b, c) == False:
        raise ValueError("Треугольник не существует")
    perimeter = calculate_perimeter_triangle(a, b, c)
    area = calculate_area_triangle(a, b, c)
    result = {'a': a, 'b': b, 'c': c, 'perimeter': perimeter, 'area': area}
    return result
print(triangle(p1=(1, 1), p2=(1, 4), p3=(5, 1)))
print()
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
def circle(p1, p2):
    # Функция для вычисления радиуса круга
    def radius(p1, p2):
        # Распаковываем кортежи для удобства
        x1, y1 = p1; x2, y2 = p2
        # Вычисляем радиус по теореме Пифагора
        r = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
        return r
    # функция для вычисления длины окружности
    def calculate_circumference(r):
        L = (2*pi) *r
        return L
    # функция для вычисления площади окружности
    def calculate_area_circle(r):
        S = pi*(r**2)
        return S
    # Вызываем функцию для вычисления радиуса
    r = radius(p1, p2)
    # Вызываем функцию для вычисления длины окружности
    L = calculate_circumference(r)
    # Вызываем функцию для вычисления площади окружности
    S = calculate_area_circle(r)
    result = {'radius': r, 'circumference': L, 'area': S}
    return result
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
def ellipse(p1, p2, p3):
    # Распаковываем кортежи для удобства, “;” означает новую строку кода
    x1, y1 = p1; x2, y2 = p2; x3, y3 = p3
    # функция для вычисления полуосей эллипса
    def semi_axes(p1, p2, p3):
        # Распаковываем кортежи для удобства, “;” означает новую строку кода
        x1, y1 = p1; x2, y2 = p2; x3, y3 = p3
        # Вычисляем стороны по теореме Пифагора
        a = ((x2 - x1) ** 2 + (y2 - y1)** 2) ** 0.5
        b = ((x3 - x1) ** 2 + (y3 - y1)** 2) ** 0.5
        return a, b

    # функция для вычисления площади эллипса
    def calculate_area_ellipse(pi, a, b):
        S = pi * a * b
        return S
    
    # функция для вычисления длины окружности эллипса
    def calculate_length_ellipse(pi, a, b):
        L = pi * (a + b) 
        return L
    a = semi_axes(p1, p2, p3)[0]
    b = semi_axes(p1, p2, p3)[1]
    # Вызываем функцию длины окружности эллипса
    L = calculate_length_ellipse(pi,a, b)
    # # Вызываем функцию длины окружности эллипса
    S = calculate_area_ellipse(pi,a, b)
    # Выводим словарь
    result = {'a':a, 'b':b, 'length':L, 'area':S}
    return result
pi = 3.1416
print(ellipse(p1=(3, 2.5), p2=(4.5, 2.5), p3=(3, 3.5)))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Рекурсия 
def sum_lst(lst):
    # Выводим текущее значение lst
    print(lst)
    # Задаём условие выхода из рекурсии
    if len(lst) == 0:
        return 0
    # Во всех других случаях возвращаем
    # сумму первого элемента списка 
    # и результат суммирования оставшихся
    return lst[0] + sum_lst(lst[1:])

my_lst = [10, 4, 8]

def multiply_lst(lst):
    # Выводим текущее значение lst
    print(lst)
    # Задаём условие выхода из рекурсии
    if not lst:
        return 1
    # Во всех других случаях возвращаем
    # сумму первого элемента списка
    # и результат произведени оставшихся
    return lst[0] * multiply_lst(lst[1:])

# PYTHON-5.2. Продвинутое использование функций в Python
# 5/10  5. Рекурсия
# Задание 5.4 (External resource)
# Напишите рекурсивную функцию inv_sum_list(). 
# На вход ей подаётся список из чисел, а она вычисляет сумму чисел, являющихся обратными к своим элементам. 
# Обратным числу x называется число 1/x. Например, обратным числу 2 является 1/2 = 0.5.
# Например, если на вход программы подается список [10, 4, 8], то функция должна вернуть сумму 0.1 + 0.25 + 0.125 = 0.475.
def inv_sum_list(lst):
    if not lst:
        return 0
    return 1 / lst[0] + inv_sum_list(lst[1:])

print(inv_sum_list([10, 4, 8]))
print(inv_sum_list([10, 1, 2, 4, 8]))
print(inv_sum_list([]))
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Рекурсия
# будут проверять на собеседовании!!!
def add_asterisk(s):
    if len(s) < 2: return s
    return s[0] + '*' + add_asterisk(s[1:])
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-5.2. Продвинутое использование функций в Python
# 6/10  6. Рекурсия. Практика
# ДРЕВОВИДНЫЕ СТРУКТУРЫ
# ЗАДАЧА №3

# Функция для удаления сообщения на форуме и всех его потомков
def delete_message(messages, msg_id):
    # Удаляем из словаря сообщение с идентификатором msg_id
    # Метод pop() возвращает значение, лежащее по удаляемому ключу
    result = messages.pop(msg_id)
    # Получаем идентификатор родителя
    parrent_link = result['parrent_link']
    # Получаем список идентификаторов потомков
    child_link = result['child_link']
    # Если у сообщения был родитель и он ещё не был удален
    # Эта запись будет аналогична parrent_link is not None
    if parrent_link and parrent_link in messages:
        # Обращаемся к словарю messages по ключу родителя
        # Удаляем потомка из списка потомков
        messages[parrent_link]['child_link'].remove(msg_id)
    # Если у сообщения были потомки
    # Эта запись будет аналогична child_link == []
    if child_link:
        # В цикле проходимся по всем потомкам 
        for child_id in child_link:
            # И повторяем те же самые действия для каждого из них
            # (рекурсивно вызываем функцию delete_message)
            delete_message(messages, msg_id=child_id)
    return messages
# Словарь форум сообщений
forum_messages = {
    1: {'parrent_link': None, 'child_link': [3, 4]},
    2: {'parrent_link': None, 'child_link': [5]},
    3: {'parrent_link': 1, 'child_link': [6]},
    4: {'parrent_link': 1, 'child_link': []},
    5: {'parrent_link': 2, 'child_link': []},
    6: {'parrent_link': 3, 'child_link': []}
}
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-5.2. Продвинутое использование функций в Python
# 8/10   8. Встроенная функция filter()
# FILTER + LAMBDA
data = [
    ("FPW-2.0_D", "Бонус: Тренажер по HTML", 10, 100, 10),
    ("FPW-2.0", "Бонус: Тренажер по JavaScript", 9.2, 70, 180),
    ("FPW-2.0_D", "Бонус: Тренажер по React", 8.5, 66.67, 68),
    ("FPW-2.0", "Бонусный: IT в современном мире", 8.64, 83.74, 856),
    ("FPW-2.0", "Бонусный: Введение", 8.73, 56.24, 745),
    ("FPW-2.0", "Бонус: D1. Знакомство с Django (NEW)", 9.76, 95.24, 21),
    ("FPW-2.0_D", "Бонус: D2. Модели (NEW)", 9.44, 77.78, 18)
]
def filter_module(module):
    # Распаковываем кортеж на пять переменных
    code, name, avg_votes, nessa, count = module
    # Создаём условия 
    cond_1 = code == "FPW-2.0"
    cond_2 = nessa >= 70
    cond_3 = count > 50
    # Условия должны выполняться одновременно
    return cond_1 and cond_2 and cond_3
new_data = list(filter(filter_module, data))
print(new_data)

# Заметим, что при желании функцию filter_module() можно переписать в виде однострочной lambda-функции:
# Создаём lambda-функцию, которая возвращает True, если модуль удовлетворяет условиям
lambda_filter_module = lambda x: (x[0] == "FPW-2.0") and (x[3] >= 70) and (x[4] > 50)
# Применяем эту функцию к каждому элементу списка (к каждому кортежу)
filtered_data = list(filter(lambda_filter_module, data))
# Смотрим, что получилось
print(filtered_data)
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика, 2/11   2. Основы Python, Задание 2.8 (External resource), 
# В переменной file_path задан полный путь до файла с изображением. Найдите его расширение,
# результат занесите в переменную file_extension.
# Также найдите имя файла (без учёта расширения), результат занесите в переменную file_name.
file_path = 'data/images/train/10394.jpg'
# Разделим строку по символу '/' , затем разделим последний элемент по символу '.' и распаковываем в переменные
file_name, file_extension = file_path.split('/')[-1].split('.')
print(file_name, file_extension)
-/-/-/-/-/-/-/-/-/-/-/-/-/-

-/-/-/-/-/-/-/-/-/-/-/-/-/-
def combination(n, k):
    def factorial(n):
        # Задаём условия выхода из рекурсии:
        if n == 0: return 1
        if n == 1: return 1
        # Во всех других случаях возвращаем
        # произведение текущего числа n и функцию от n-1
        return factorial(n-1)*n
    C = factorial(n) / (factorial(n-k) * factorial(k))
    return C
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
def check(string, ch):
    if not string:
        return 0
    elif string[0] == ch:
        return 1 + check(string[1:], ch)
    else: 
        return check(string[1:], ch)
string = input("Введите строку:")
ch = input("Введите букву для проверки:")
print("Количество вхождений:")
print(check(string, ch))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Последовательность Фибоначчи
def fibonacci(n):
    if (n <= 1):
        return n
    else:
        return (fibonacci(n-1) + fibonacci(n-2))
n = int(input("Введите число членов последовательности:"))
print("Последовательность Фибоначчи:")
for i in range(n):
    print(fibonacci(i))
-/-/-/-/-/-/-/-
def fib(n):
    if n == 1 or n == 2: return 1
    else:
        return (fib(n-1) + fib(n-2))
-/-/-/-/-
# Рекурсивная функция определения степени чисел
def power(val, n):
    if n == 0: return 1
    if n == 1: return val
    return (val * power(val, n-1))
print(power(2,4))
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# функция вычисления числа Фибоначчи
fib1 = fib2 = 1

n = int(input('Введите ряд Фибоначчи:\t'))

print(fib1, fib2, end=' ')

for i in range(2, n):
    fib1, fib2 = fib2, fib1 + fib2
    print(fib2, end=' ')
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Функция для создания строки со скобками через рекурсию
def add_brackets(s):
    # проверяем условия остановки: строка состоит 
    # из одного или двух символов
    if len(s) <= 2:
        # Возвращаем эти символы
        return s
    # В противном случае
    #"Отщипываем" от строки первый и последний символы,
    # добавляем к ним скобки а так же результат вызова
    # функции в которую передаём
    # строку без первого и последнего символов
    return s[0] + '(' + add_brackets(s[1:-1]) + ')' + s[-1]
# Функция для создания строки со скобками через цикл
-/-/-/-/-/-/-/-/-/-/--/--/-/-/-/-/
# Функция для создания строки со 
# звёздочками месжду символов
def add_asterisk(s):
    # Задаём условия выхода из рекурсии, когда
    # длинна строки равна единице верни строку
    if len(s) == 1: return s
    # отщепнём первый символ строки
    # добавим здёздочку потом
    # запускаем снова саму функцию без предыдущего символа
    return s[0] + '*' + add_asterisk(s[1:])
-/-/-/-/-/-/-/-/-/-/-/-/-
# Функция для выпрямления списка
def flatten(lst):
    # Создаём новый пустой список
    result = []
    # Создаём цикл по элементам списка
    for elem in lst:
        # Если элемент списка является списком,
        if type(elem) is list:
            # Применим к нему функцию выпрямления 
            # и добавляем элементы к результату
            result += flatten(elem)
        # (в противном случае) если элемент не является 
        # списком добавляем это элемент в новый список
        else:
            result.append(elem)
    return result

# Функция для выпрямления списка
def sum_list(lst):
    # создаём переменную с результатом
    result = 0
    # создаём цикл по спискам
    for elem in lst:
        # если тип элемента является списком
        if type(elem) is list:
            # в переменную с результатом добавляем саму
            # функцию для выпрямления списка
            result += sum_list(elem)
        # в противном случае
        else: 
            # в переменную с результатом 
            # добавляем элемент из списка
            result += elem
    # возвращаем результат
    return result
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
forum_messages = {
    1: {'parrent_link': None, 'child_link': [3, 4]},
    2: {'parrent_link': None, 'child_link': [5]},
    3: {'parrent_link': 1, 'child_link': [6]},
    4: {'parrent_link': 1, 'child_link': []},
    5: {'parrent_link': 2, 'child_link': []},
    6: {'parrent_link': 3, 'child_link': []}
}
# Функция для удаления сообщения на форуме и всех его потомков
def delete_message(messages, msg_id):
    # Удаляем из словаря сообщение с идентификатором msg_id
    result = messages.pop(msg_id) # Метод pop() возвращает значение, лежащее по удаляемому ключу
    parrent_link = result['parrent_link'] # Получаем идентификатор родителя
    child_link = result['child_link'] # Получаем список идентификаторов потомков
    # Если у сообщения был родитель и он ещё не был удален
    if parrent_link and parrent_link in messages: # Эта запись будет аналогична parrent_link is not None
        messages[parrent_link]['child_link'].remove(msg_id)  # Обращаемся к словарю messages по ключу родителя
        # удаляем потомка из списка потомков
    if child_link: # Если у сообщения были потомки, Эта запись будет аналогична child_link == []
        for child_id in child_link: # В цикле проходимся по всем потомкам
            # И повторяем те же самые действия для каждого из них
            delete_message(messages, child_id) # (рекурсивно вызываем функцию delete_message)
    return messages 
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Список зарплат
salaries = [1500, 2200, 3500, 1200]
def calculate_tax(salary):
    if salary < 1000:
        return salary * 0.05
    elif salary < 2000:
        return salary * 0.1
    else:
        return salary * 0.15
    
taxes = list(map(calculate_tax, salaries))
print(taxes)
-/-/-/-/-/-/-/-/-/-/-
quotes_dict = {
    'Преступление и наказание': 'А знаешь ли... что низкие потолки и тесные комнаты душу и ум теснят.', 
    'Война и мир': 'И нет величия там, где нет простоты, добра и правды.', 
    'Анна Каренина': 'Если искать совершенства, то никогда не будешь доволен.', 
    'Детство': 'Правил у нас много, а правды нет.', 
    'Колесо времени': 'Ничто так на соединяет людей, как улыбка.'
}
test_text = ('Детство', 'Правил у нас много, а правды нет.')
# Функция для преобразования одного элемента списка кортежей
def preprocessing_quoutes(name_quotes_tuple):
    name, text = name_quotes_tuple # Разделяем составляющие кортежа на отдельные переменные
    text = text.lower() # Приводим текст к нижнему регистру
    text = text.replace('.', '') # Заменяем точки на ничего
    text = text.replace(',', '') # Заменяем запятые на ничего
    words = text.split(' ') # Разделяем слова пробелами и заносим в переменную words
    return (name, words) # Возвращаем кортеж из названия произведения и текст в виде списка

processed_quotes_dict = dict(map(preprocessing_quoutes, quotes_dict.items()))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
data = [('Amanda', 1.61, 51), ('Patricia', 1.65, 61), ('Marcos', 1.91, 101), ('Timur', 1.72, 80)]
map_func = lambda x: (*x, round(x[2]/(x[1]**2), 1))
new_data = list(map(map_func, data))
print(new_data)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
docs = [  
'//doc/5041434?query=data%20science',  
'//doc/5041567?query=data%20science',  
'//doc/4283670?query=data%20science',  
'//doc/3712659?query=data%20science',  
'//doc/4997267?query=data%20science',  
'//doc/4372673?query=data%20science',  
'//doc/3779060?query=data%20science',  
'//doc/3495410?query=data%20science',  
'//doc/4308832?query=data%20science',  
'//doc/4079881?query=data%20science'  
]
links = list(map(lambda name: "https://www.kommersant.ru" + name, docs))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
data = [(0.00632, 6.575, 65.2, 296.0, 4.98),
(0.02985, 6.43, 58.7, 222.0, 5.21),  
(0.08829, 6.012, 66.6, 311.0, 12.43)]

updated_data = list(map(lambda x: (*x, round(x[0]*x[3]*x[4], 2)), data))
print(updated_data)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
data = [
    ("FPW-2.0_D", "Бонус: Тренажер по HTML", 10, 100, 10),
    ("FPW-2.0", "Бонус: Тренажер по JavaScript", 9.2, 70, 180),
    ("FPW-2.0_D", "Бонус: Тренажер по React", 8.5, 66.67, 68),
    ("FPW-2.0", "Бонусный: IT в современном мире", 8.64, 83.74, 856),
    ("FPW-2.0", "Бонусный: Введение", 8.73, 56.24, 745),
    ("FPW-2.0", "Бонус: D1. Знакомство с Django (NEW)", 9.76, 95.24, 21),
    ("FPW-2.0_D", "Бонус: D2. Модели (NEW)", 9.44, 77.78, 18)
]
# Создаём lambda-функцию, которая возвращает True, если модуль удовлетворяет условиям
lambda_filter_module = lambda x: (x[0] == "FPW-2.0") and (x[3] >= 70) and (x[4] > 50)
def filter_module(module):
    # Распаковываем кортеж на пять переменных
    code, name, avg_votes, nessa, count = module
    # Создаём условия 
    cond_1 = code == "FPW-2.0"
    cond_2 = nessa >= 70
    cond_3 = count > 50
    # Условия должны выполняться одновременно
    return cond_1 and cond_2 and cond_3
filtered_data = list(filter(filter_module, data))
-/-/-/-/-/-/-/-/-/-/-/-/-
def filter_family(list1):
    family_list = [
        'certificate of a large family',
        'social card',
        'maternity capital',
        'parking permit',
        'tax benefit',
        'reimbursement of expenses',
        "compensation for the purchase of children's goods"
    ]
    result = list(filter(lambda x: x in family_list, list1))
    return result
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
words_list = ["We're", 'in', 'a', 'small', 'village', 'near', 'Chicago', 'My', "cousin's", 'getting', 'married.']
count_a = []
# Отбираем слова из пяти и более букв
filtered_words = filter(lambda x: len(x) >= 5, words_list)
# Все отобранные слова переводим в нижний регистр и считаем число букв 'a' в них
# Результат выдаём в виде кортежа (слово, количество букв "a")
count_a = map(lambda x: (x, x.lower().count('a')), filtered_words)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Выгрузка данных о параметрах человеческого тела
data = [
    ('Amanda', 1.61, 51),
    ('Patricia', 1.65, 61), 
    ('Marcos', 1.91, 101),
    ('Andrey', 1.79, 61),
    ('Nikos', 1.57, 78),
    ('Felicia', 1.63, 56),
    ('Lubov', 1.53, 34)
]
# Создаём lambda-функцию, которая считает BMI, и применяем её к каждому элементу списка
map_func = lambda x: (*x, round(x[2] / (x[1]**2), 2))
update_data = map(map_func, data)
filtered_func = lambda x: 18.5 <= x[3] <= 25
filtered_data = filter(filtered_func, update_data)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Список пользователей
reg = [('Ivanov', 'Sergej', 24, 9, 1995),
      ('Smith', 'John', 13, 2, 2003),
      ('Petrova', 'Maria', 13, 3, 2003)]
# Функция фильтрации рожденных после 2000 года
filter_func = lambda x: x[4] >= 2000
# Создаем переменную и отфильтровываем рожденных после 2000 года к списку пользователей
filtered_reg = filter(filter_func, reg)
# Создаем функцию в которой создаем кортеж из строки фамилия + 1я буква имени с точкой, и даты рождения
map_cut_name = lambda x: (x[0] + ' ' + x[1][0] + '.', x[2],x[3],x[4])
# Создаем переменную и применяем к ней функцию map, с нашей
# функцией изменениея имени map_cut_name и применяем к нашему 
# отфильтрованному списку filtered_reg
new_reg = list(map(map_cut_name, filtered_reg))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
data = [(0.00632, 6.575, 65.2, 296.0, 4.98),
 (0.02731, 6.421, 78.9, 242.0, 9.14),
 (0.02729, 7.185, 61.1, 242.0, 4.03),
 (0.03237, 6.998, 45.8, 222.0, 2.94),
 (0.06905, 7.147, 54.2, 222.0, 5.33),
 (0.02985, 6.43, 58.7, 222.0, 5.21),
 (0.08829, 6.012, 66.6, 311.0, 12.43)]
map_func = lambda x: (*x, round(x[0]*x[3]*x[4],2))
map_data = map(map_func, data)
filter_func = lambda x: x[5] > 60
filtered_data = list(filter(filter_func, map_data))
print(filtered_data)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Дана строка со словами
input_string = 'Hello! My name is Python. I will help you to analyze some data.'
# Список символов для удаления
symbol_list = ['.', ',', '!', '?']
# Пустая строка для очищеных от символов слов 
new_string = ''
# Создаём цикл по словам из строки
for word in input_string:
    for symbol in word:# Создаём цикл по буквам из слов
        if symbol in symbol_list:
            continue # Если символ присутствует в списке слов для удаления то мы его пропускаем
        else: # в противном случае, мы добавляем символ с в строку для очищеных от символов слов
            new_string += symbol
# Создаём переменную со строкой разделённой по словам
test_count = new_string.split()
# Создаём переменную в которой считаем количество слов в строке
count_words = len(test_count)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
input_string = 'Hello! My name is Python. I will help you to analyze some data.'
# другой подход от ментора Ольги Белоглазовой к этой же задаче
list_element = ['!', '.', ',', '?'] # Список символов для удаления
for element in list_element: # Создаём цикл по словам из списка удаляемых символов
    input_string = input_string.replace(element, '') # обращаемся к исходной строке и перезаписываем элемент на пустоту
words = input_string.split(' ') # Создаём переменную и сохраняем в неё нашу изменённую строку и разделяем на пробелы
count_words = len(words) # Создаём переменную и считаем в ней количество слов из предыдущей переменной
/-/-/-/-/-/-/-/-/-/-/-/-/-/-/
file_path = 'data/images/train/10394.jpg' #
test1 = file_path.split('/') #
test2 = str(test1[-1]).split('.') #
file_name = str(test2[0]) #
file_extension = test2[1] #
print(file_name) #
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Дана строка в которой надо развернуть строку по словам слева на право
generated_text = "глаза нее на поднял он и она попросила что-нибудь скажи"
test1 = generated_text.split(' ') #разделяем строку по пробелам(не смотря на то что они есть)
updated_text =  ' '.join(test1[::-1]) #рзворачиваем строку по словам слева на право методом.join()удалет кавычки и [скобки]
print(updated_text) #выводим на экран
-/-/-/-/-/-/-/-/-/-
# Найдите: 1) среднюю стоимость автомобиля, 2) количество с дизелем, 3) мин. мощьность двигателя
car_dict = {
    'car_ID': [123, 117, 111, 82, 101, 96, 156, 2, 58, 49],
    'fueltype': ['gas', 'diesel', 'diesel', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas'],
    'horsepower': [68, 95, 95, 88, 97, 69, 62, 111, 101, 176],
    'price': [7609.0, 17950.0, 13860.0, 8499.0, 9549.0, 7799.0, 8778.0, 16500.0, 13645.0, 35550.0]
}
mean_price = round(sum(car_dict.get('price')) / len(car_dict.get('price')), 2) # средняя стоимость автомобилей
count_diesel = len(list(filter(lambda x: x == 'diesel', car_dict['fueltype']))) # количество с дизельным двигателем
min_horsepower = min(car_dict.get('horsepower')) # мин мощность двигателя в лошадиных силах
print(count_diesel)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Напишите функцию check_duplicates(), которая проверит, есть ли дубликаты в списке lst, переданном ей в качестве аргумента.
lst = [0, 0, 1, 2, 3, 4, 5, 5, 6, 7]
def check_duplicates(lst):
    # посчитать и сравнить входной список и 
    # преобразованный в множество на неравенство
    return len(lst) != len(set(lst))
print(check_duplicates(lst))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6, Задание 3.7
# Напишите функцию swap_places(), которая принимает 
# в качестве аргумента список lst и меняет местами 
# его первый и последний элементы.
# Функция должна возвращать обновлённый список.
lst = range(1, 6)
# мой код
def swap_places(lst):
    result = [lst[-1]]
    result.extend(lst[1:-1])
    result.append(lst[0])
    return result
# код от преподавателя
def swap_places(lst):
    lst[0], lst[-1] = lst[1], lst[0]
    return lst
-/-/-/-/-/-/-/-/-/-/-/-/--/-/-/-/-/-/
# PYTHON-6, Задание 3.8
# Напишите функцию equalize_lengths(), которая принимает на вход список 
# и возвращает новый список из строк одинаковой длины. Длина итоговой
# строки должна быть равна длине самой длинной из строк. 
# Если конкретная строка короче самой длинной, её необходимо дополнить 
# до требуемого количества символов нижними подчёркиваниями с правого края.
lst = ['крот', 'белка', 'выхухоль', 'мох', 'он']
def equalize_lengths(lst): # Создаём функцию
    lst.sort(key=lambda x: len(x), reverse = True) # Сортируем по количеству и разворачиваем от большего к меньшему
    max_word = len(lst[0]) # Считаем макс количество первого слова(отсортированного списка)
    new_lst = [] # Создаём новый пустой список
    for word in lst: # Создаём цикл
        if len(word) == max_word: # Если длинна слова равна переменной макс количества
            new_lst.append(word) # Добавляем это слово в новый список
        if len(word) < max_word: # Если длинна слова меньше макс количества
            count_symbol = max_word - len(word) # Создаём переменную и считаем разницу макс и текущей длинны слова
            new_lst.append(word + ('_' * count_symbol)) # Добавляем это слово в новый список и прибавляем к нему символы '_'
    return new_lst # Возвращаем обновлённый список

# PYTHON-6. Практика. Задание 4.6
# Напишите, функцию find_min_number(), воспользовавшись условными операторами,
# которая принимает на вход три числа (a, b, c) и возвращает наименьшее из них.
def find_min_number(a, b, c):
    if b > a < c:
        return a
    if a > b < c:
        return b
    if a > c < b:
        return c
# Решение препода:
def find_min_number(a, b, c): # Поиск минимального числа из трех
    min_number = 0 # Пустая переменная для минимального числа
    if a < b: # Если 'а' меньше 'б'
        min_number = a # Заносим значение 'а' в переменную для минимального числа
    else: # В противном случае
        min_number = b # Заносим значение 'б' в переменную для минимального числа
    if min_number > c: # Если переменная для минимального числа меньше 'с'
        min_number = c # Заносим 'с' в переменную для минимального числа
    return min_number # Возвращаем результат
-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. Задание 4.7
# Напишите функцию sum_min_numbers(), которая также принимает 
# на вход три числа (a, b, c) и возвращает сумму двух наименьших.
def sum_min_numbers(a, b, c):
    if b > a < c:
        if b < c:
            return a + b
        else:
            return a + c
    if a > b < c:
        if a < c:
            return b + a
        else:
            return b + c
    if a > c < b:
        if a < b:
            return c + a
        else:
            c + b
# Решение препода:
def sum_min_numbers(a, b, c): # Функция суммы двух минимальных чисел из трех
    min_number = find_min_number(a, b, c) # Заносим минимальный результат предыдущей функции
    number_list = [a, b, c] # Помещаем в переменную наши три числа
    number_list.remove(min_number) # Удаляем из списка минимальное(аргумент мин функция)
    if number_list[0] < number_list[1]: # Если из оставшихся двух первый элемент меньше
        min_sum = number_list[0] + min_number # Первый элемент суммируем с минимильным
    else: # В противном случае
        min_sum = number_list[1] + min_number # Второй элемент суммируем с минимальным
    return min_sum # Возвращаем результат
-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. Задание 4.8
# Напишите функцию division(a, b), которая принимает на вход два числа, делимое (a) и делитель (b), и возвращает частное.
# Необходимо реализовать внутри функции отлов исключения ZeroDivisionError
# Функция должна вывести на экран сообщение "Zero division error!" с помощью функции print(), а затем 
# вернуть значение None из функции, если пользователь при вызове функции попытается поделить на ноль.
def division(a, b):
    try:
        return a / b
    except ZeroDivisionError as e:
        print("Zero division error!")
        return None
    
print(division(1, 0))
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. Задание 4.9
# Напишите функцию get_prediction(), которая принимает на вход два аргумента (x1 и x2) и 
# возвращает число, предсказанное моделью, приведённой на схеме выше.
# Примечание. Предсказания модели записаны в зелёных прямоугольниках.
def get_prediction(x1, x2):
    if x1 < 20:
        if x2 < 200:
            return 300.5
        else:
            return 65.7
    else:
        if x2 < 170:
            if x1 < 40:
                return -64.1
            else:
                return 0.7
        else:
            return 1023
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# Что означает больше n по модулю??? я так понимаю это не совсем сравнение по модулю
# (число 'а' сравнимо с 'в' по модулю n тогда и только тогда, 
# когда 'а' и 'в' имеют одинаковый остатки при делении на 'n') 
# и почему вы решаете тут через 'abs' и что это такое, я что-то пропустил?
# PYTHON-6. Практика. Задание 5.4
# Напишите функцию more_than_n(), которая принимает на вход два аргумента: список чисел lst и число n
# Функция должна возвращать новый список, в котором содержатся только те числа, которые больше n по модулю.
# Если в функцию был передан пустой список, то функция также должна вернуть пустой список.
def more_than_n(lst, n):
    new_lst = []
    if not lst:
        return new_lst
    else:
        for i in lst:
            if abs(i) > n:
                new_lst.append(i)
    return new_lst
print(more_than_n([-1, 4, 4.2, 42.2, -3.4, -5.2], 3))
print(more_than_n([], 10))
-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. Задание 5.5
# Напишите функцию которая проверяет, является ли билет счастливым. Билет счастливый, если
# сумма первых трёх цифр в его номере равна сумме последних трёх цифр. На вход функция принимает
# шестизначное число ticket_number и должна возвращать одно из булевых значений (True или False)
# в зависимости от того, является ли билет счастливым. 
# постарайтесь не использовать встроенную функцию sum() — примените циклы.
def lucky_ticket(lst):
    var1 = str(lst)[:3]
    var2 = str(lst)[3:]
    sum1 = 0
    sum2 = 0
    for i in var1:
        sum1 += int(i)
    for i in var2:
        sum2 += int(i)
    if sum1 == sum2:
        return True
    else:
        return False
print(lucky_ticket(111111))
-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. Задание 5.6
# Напишите функцию которая принимает на вход число (number), подсчитывает
# общее количество отверстий в заданном числе и возвращает результат.
# Условимся, что цифрами с отверстиями будем считать (0, 4, 6, 8 и 9). 
# Причём в цифре (8) отверстий два, а в остальных — по одному.
def holes_count(number):
    lst = [0, 4, 6, 8, 9] # Создаем список с отверстиями
    count = 0 # Создаем переменную для подсчёта
    for i in str(number): # Создаём цикл по входным данным, преобразовав в строку
        if i in str(lst): # Если строковый элемент присутствует в строковом списке отверстий
            if i == str(8): # Если строковый элемент равен 8
                count += 2 # Пополняем переменную для подсчёта на два
            else: # В противном случае
                count += 1 # Пополняем переменную для подчёта на один
    return count # Возвращаем полученый результат

print(holes_count(8))
# 2
print(holes_count(146))
# 2
print(holes_count(84628))
# 6
-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. Задание 5.7
# Напишите функцию even_numbers_in_matrix(), которая получает на вход матрицу
# (список из списков) matrix и возвращает количество чётных чисел в ней.
def even_numbers_in_matrix(matrix):
    count_matrix = 0 # Создаём переменную для подсчёта 
    for i in matrix:# Создаём цикл по матрице
        for j in i: # Создаём цикл по строке
            if j % 2 == 0: # Если элемент строки чётный
                count_matrix += 1 # Добавляем в переменную для подсчёта
    return count_matrix # Возвращаем результат
matrix_example = [[1, 5, 4],[4, 2, -2],[7, 65, 88]] # Матрица 
print(even_numbers_in_matrix(matrix=matrix_example)) # Выводим на экран наш код
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. Задание 5.8
# Двумерные таблицы (матрицы) — основной формат данных, с которым мы будем работать.
# Давайте рассмотрим операцию сложения двух матриц. Напишите функцию matrix_sum(),
# которая получает на вход две матрицы (matrix1, matrix2) и возвращает их сумму.
def matrix_sum(matrix1, matrix2):
    new_matrix = []
    if len(matrix1) == len(matrix2) and len(matrix1[0]) == len(matrix2[0]):
        for i in range(len(matrix1)):
            row = []
            for j in range(len(matrix1[0])):
                elem = matrix1[i][j] + matrix2[i][j]
                row.append(elem)
            new_matrix.append(row)
    else:
        print(('Error! Matrices dimensions are different!'))
        return None
    return new_matrix
matrix1_example = [
          [1, 5, 4],
          [4, 2, -2],
          [5, 8, 12]
]
matrix2_example = [
          [10, 15, 43],
          [41, 2, -2],
          [7, 5, 7]
]
print(matrix_sum(matrix1=matrix1_example, matrix2=matrix2_example))
# Error! Matrices dimensions are different!
# None
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика, 6/11   6. Функции, Задание 6.6 (External resource)
# Напишите функцию get_words_list(), которая: избавляется от знаков препинания в тексте, 
# приводит текст к нижнему регистру, возвращает список из слов в тексте.
# Для решения задачи вы можете использовать готовый список со знаками препинания:
text_example = "Arrakis, the planet known as Dune, is forever his place."
# Создаём функцию очистки текста от знаков припинания
def get_words_list(text):
    # Создаём список знаков припинания которые будем удалять
    punctuation_list = ['.', ',', ';', ':', '...', '!', '?', '-', '"', '(', ')']
    # Приводим текст в нижний регистр
    text = text.lower()
    # Создаём цикл по списку знаков припинания
    for word in punctuation_list:
        # в тексте перезаписываем итерируемый знак припинания на пустые кавычки(на ничего)
        text = text.replace(word, '')
    # Сохраняем наш текст в список разделённый пробелами
    new_text = text.split()
    # Возвращаем полученный список
    return new_text
print(get_words_list(text=text_example))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика, 6/11   6. Функции. Задание 6.8
def get_most_frequent_word(text):
    def get_words_list(text):
        # Создаём список знаков припинания которые будем удалять
        punctuation_list = ['.', ',', ';', ':', '...', '!', '?', '-', '"', '(', ')']
        # Приводим текст в нижний регистр
        text = text.lower()
        word_list = []
        # Создаём цикл по списку знаков припинания
        for word in punctuation_list:
            # в тексте перезаписываем итерируемый знак припинания на пустые кавычки(на ничего)
            text = text.replace(word, '')
            # Сохраняем наш текст в список разделённый пробелами
            word_list = text.split()
            # Возвращаем полученный список
        return word_list
    # Создаём функцию сортировки по алфавиту уникальных слов
    def get_unique_words(words_list):
        # преобразовываем в множество и применяем сортировку
        result = sorted(set(words_list))
        return result
    # Создаём список очищенный от знаков припинания слов
    pure_word_list = get_words_list(text)
    # Создаём спискок уникальных слов
    unic_word_list = get_unique_words(pure_word_list)
    # Создаём переменную с максимальным значением
    max_word_count = 0
    # Создаём переменную с популярным словом
    popular_word = ''
    # Создаём цикл по уникальным словам
    for word in unic_word_list:
        # Создаём временную переменную с количеством вхождений
        word_count = pure_word_list.count(word)
        # Если временная переменная больше максимальной
        if word_count > max_word_count:
            # Перезаписываем в переменную с максимальным значением
            max_word_count = word_count
            # Перезаписываем популярное слово
            popular_word = word
    return popular_word
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
# PYTHON-6. Практика. 6/11  6. Функции. Задание 6.9
data = [
    ('Amanda', 37, 78, 67),
    ('Patricia', 78, 93, 68),
    ('Marcos', 79, 67, 89),
    ('Dmitry', 67, 68, 100),
    ('Andrey', 100, 78, 76),
    ('Victoria', 93, 69, 96),
]
# добавляет в каждый кортеж новый элемент — общий балл по всем трём экзаменам, 
# сортирует данные по общему баллу и возвращает полученный результат
def get_total_score(data):
    # Лямбда функция добавления в кортеж общего балла по всем трём экзаменам
    map_func = lambda x: (*x, round(x[1]+x[2]+x[3]))
    # Применяем нашу лямбда функцию и заносим новые данные в переменную
    new_data = list(map(map_func, data))
    # Сортируем получившийся список по новому элементу и заносим в переменную
    result = sorted(new_data, key=lambda x: x[4])
    # Возвращаем получившийся результат
    return result
print(get_total_score(data))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
data = {
    "type": "video",
    "videoID": "vid001",
    "links": [
        {"type":"video", "videoID":"vid002", "links":[]},
        {   "type":"video",
            "videoID":"vid003",
            "links": [
            {"type": "video", "videoID":"vid004"},
            {"type": "video", "videoID":"vid005"},
            ]
        },
        {"type":"video", "videoID":"vid006"},
        {   "type":"video",
            "videoID":"vid007",
            "links": [
            {"type":"video", "videoID":"vid008", "links": [
                {   "type":"video",
                    "videoID":"vid009",
                    "links": [{"type":"video", "videoID":"vid010"}]
                }
            ]}
        ]},
    ]
}
# Функция обработки видео тегов
def find_video(data):
    # Создаём пустой список
    new_list = []
    # Проходимся циклом по нашим данным
    for key in data:
        # Если итовый объект это список
        if type(data[key]) is list:
            # Проходимся циклом по списку
            for elem in data[key]:
                # Применяем рекурсивно функцию и аргументом передаём итовый объект
                new_list += find_video(elem)
        # Если название ключа "videoID"
        if key == 'videoID':
            # Добавляем значение ключа в новый список
            new_list.append(data[key]) 
    return new_list
print(find_video(data))
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
## PYTHON-6. Практика. 7/11, 7. Тематический проект.
# Дан словарь, ключ это название сыра, а значение ключа его характеристики
cheese_data = {
    'чеддер': [370, 5000, 33, 'твердый'],
    'пармезан': [510, 4000, 29, 'твердый'],
    'гауда': [250, 3700, 27, 'полутвердый'],
    'эдам': [220, 10000, 30, 'полутвердый'],
    'горгонзола': [320, 3000, 32, 'полумягкий'],
    'рокфор': [340, 15000, 31, 'полумягкий'],
    'стилтон': [360, 7000, 35, 'полумягкий'],
    'камамбер': [250, 8000, 24, 'мягкий'],
    'бри': [310, 6500, 28, 'мягкий'],
}
# Задание 7.1
# Функция фильтрации сыров по жирности
def filter_by_fat(data, n):
    # Создаём новый словарь
    new_dict = {}
    # Проходимся циклом по словарю разбив его на кортеж
    for row in data.items():
        # Создаём переменную с именем сыра
        name = row[0]
        # Создаём переменную с жирностью сыра
        fat = row[1][2]
        # Если жирность сыра меньше n-ного значения
        if fat < n:
            # Заносим в словарь имя и жирность
            new_dict[name] = fat
    # Возвращаем получившийся словарь        
    return new_dict
#print(filter_by_fat(cheese_data, n=30))

# Задание 7.2
# Функция подсчёта дохода при максимальной нагрузке
def count_money(data):
    # Создаём новый список
    temp_list = []
    # Проходимся циклом по словарю, предварительно 
    # преобразовав его в списки кортежей
    for row in data.items():
        # Создаём переменную с ценой за 1 кг
        zak_cena = row[1][0]*10
        # Сохраняем отдельно максимальный объём производства данного типа сыра
        max_proiz = row[1][1]
        # Добавляем в список максимальный доход этого типа сыра
        temp_list.append(zak_cena * max_proiz)
    # Возвращаем общую сумму, доход при максимальном производстве всех типов сыров
    return sum(temp_list)

# Задание 7.3
# Фунция поиска назавания сыров по типу,принимает два аргумента, 
# словарь и тип сыра, а возвращает список подходящих по параметрам
def find_cheese_type(cheese_data, cheese_type):
    # Создаём новый список
    cheese_list = []
    # Проходимся циклом по словарю, предварительно 
    # преобразовав его в списки кортежей
    for row in cheese_data.items():
        # Создаём переменную с именем сыра
        name = row[0]
        # Создаём переменную с типом сыра
        cheese = row[1][3]
        # Если тип сыра подходящий
        if cheese == cheese_type:
            # Добавляем в список
            cheese_list.append(name)
    # Возвращаем полученый список
    return cheese_list

# Задание 7.4
# Фунция сортировки сыров по возрастанию стоимости
def sort_cheese(data):
    # Создаём новый список
    sorted_cheese = []
    # Создаём цикл name и в качестрве аргумента передаем на сам словарь
    # а отсортированный методом .sorted по значению словарь
    for name in sorted(data, key=data.get):
        # Добавляем имя сыра в наш новый список
        sorted_cheese.append(name)
    # Возвращаем полученный список
    return sorted_cheese

# Задание 7.5
# Функция проверки дубликатов в заказе 
def purchase(data):
    # Если длинна списка равна длинне уникального списка(дубликатов не имеется)
    if len(data) == len(set(data)):
        # Выводим на экран фразу
        print("Ваш заказ оформлен верно")
    # Иначе
    else:
        # Проходимся циклом по сортированному уникальному списку
        for i in sorted(set(data)):
            # Если текущий элемент более одного раза встречается в списке
            if data.count(i) > 1:
                # Выводим на экран фразу
                print(f"Вы продублировали ингредиент {i} в заказе {data.count(i)} раз(а)")
ingredients = ['кислота уксусная', 'кислота лимонная', 'закваска', 'кислота молочная', 'пряность', 'бактерии', 'аннато', 'кальций', 'калий', 'специя', 'молоко коровье', 'молоко овечье', 'фермент', 'соль', 'сливки', 'грибки', 'ароматизатор', 'молоко козье', 'дрожжи', 'каротин']
ingredients = ['молоко коровье', 'молоко овечье', 'бактерии', 'молоко козье', 'сливки', 'фермент', 'закваска', 'молоко коровье', 'соль', 'молоко коровье', 'бактерии', 'молоко овечье', 'кислота лимонная', 'грибки', 'соль', 'дрожжи', 'кислота уксусная', 'кальций', 'калий', 'каротин', 'аннато', 'специя', 'пряность', 'ароматизатор', 'соль', 'кислота молочная']
purchase(ingredients)
-/-/-/-/-/-/-/-/-/-/-/-/-/-/-
'''