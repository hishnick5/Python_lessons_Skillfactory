
##1
#input_string1 = input('Введите 1-ую последовательность идентификаторов: ')
#input_string2 = input('Введите 2-ую последовательность идентификаторов: ')
# ваш код здесь
# Функция для проверки пересечений
def pure_intersection(input_string1, input_string2):
    # Создаём новый список для пересечений
    result = []
    # Создаём конструкцию для отлова ошибок ввода
    try:
        # в 'map' передаём функцию 'int' и сплитанутый ввод чисел, и преобразовываем это всё в список.
        first = list(map(int, input_string1.split(',')))
        second = list(map(int, input_string2.split(',')))
    # Если возникает ошибка ввода данных
    except ValueError:
        # Выводим на экран
        print('Некорректный ввод')
    # Если ошибки не возникло
    else:
        # Проверяем пересечения преобразовав в множества, 
        # а результат конвертируем в список и передаём в вышесозданную переменную 'result'
        result = list(set(first).intersection(set(second)))
        # Возвращаем получившийся результат
        return result

##2
#input_string = input('Введите последовательность чисел: ')
# ваш код здесь
## Функция поиска и вывода на экран минимального и максимального значений, вводимых с клавиатуры
## Внимание! здесь подразумевается что в функцию не будут вводиться слова
# слитые с точкой к примеру "папа.Карло" иначе в код можно добавить сначала
# удаление точек в виде: input_string.replace('.', ' ')  а только потом
# заменить запятые(в дробных числах) на точки: input_string.replace(',', '.')
def find_min_max(input_string):
    # Заменяем запятую на точку, сплитуем по пробелам (получаем список строк)
    temp = input_string.replace(',', '.').split()
    # Создаём новый список
    new_list = []
    # Проходимся циклом по полученному списку строк
    for elem in temp:
        # Проверяем, если строка состоит только из букв
        if elem.isalpha():
            # Пропускаем
            continue
        # Иначе
        else:
            # Проверяем, если строка состоит только из цифр
            if elem.isdigit():
                # Добавляем в список, преобразовав в целое число
                new_list.append((int(elem)))
            # Иначе(подразумевается что в переменной 
            # строка в виде дробного числа, т.е. число с плавающей точкой)
            else:
                # Добавляем в список, преобразовав в число с плавающей точкой
                new_list.append(float(elem))
    # Выводим на экран минимальное и максимальное значение из полученного списка
    print('Minimum:', min(new_list))
    print('Maximum:', max(new_list))
#find_min_max(input_string)

##3
# test = input('Введите последовательность чисел: ')
# Функция поиска и вывода на экран медианы
def find_median(test):
    # Создаём конструкцию для отлова ошибок ввода
    try:
        # с помощью 'мар' конвертируем введенные значения в числовые данные предварительно сплитанув по запятым
        # далее преобразовываем в список, сортируем по возрастанию и заносим в переменную
        lst = sorted(list(map(int, test.split(','))))
    # Если возникает ошибка ввода данных (введены не числовые стоки а буквенные)
    except ValueError:
        # Выводим на экран
        print('Некорректный ввод')
    # Если ошибки не возникло
    else:
        # Создаём функцию поиска медианы
        def even_func(lst):
            # Если в списке 2 элемента
            if len(lst) == 2:
                # Суммируем и делим пополам
                result = (lst[0]+lst[1])/2
                # Возвращаем получившийся результат
                return result
            # Если в списке один элемент
            if len(lst) == 1:
                # Возвращаем этот элемент из списка
                return float(lst[0])
            # А если в списке более друх элементов, вызываем эту же функцию рекурсивно 
            # и в качестве аргумента передаём в неё список кроме 
            # первого и последнего элемента
            return even_func(lst[1:-1])
        # Вызываем нашу функцию и сохраняем полученый результат
        result = even_func(lst)
        # Выводим на экран результат
        print('Median:', result)
# find_median(test)
##4
#
# input_string = input('Введите числа словами')
# Функция для перевода строчных чисел в цифровые
def transform_string_to_integer(input_string):
    # Словарь для склейки слов в числа
    number_word_dict = {
        "ты": 1000, "м": 1000000,
        "сто": 100, "двес": 200, "трис": 300, "четырес": 400, "пятьс": 500, "шестьс": 600, "семьс": 700, "восемьс": 800, "девятьс": 900,
        "одинн": 11, "двен": 12, "трин": 13, "четырн": 14, "пятн": 15, "шестн": 16, "семн": 17, "восемн": 18, "девятн": 19,
        "двад": 20, "трид": 30, "сор": 40, "пятьд": 50, "шестьд": 60, "семьд": 70, "восемьд": 80, "девяно": 90,
        "дес": 10, "н": 0, "о": 1, "дв": 2, "т": 3, "ч": 4, "п": 5, "ш": 6, "с": 7, "в": 8, "д": 9, }
    # Создаём переменную с суммой
    sum = 0
    # Создаём временную переменную
    tmp = 0
    # Создаём список из слов введенных с клавиатуры
    words = input_string.split()
    # Получаем список ключей из нашего словаря
    keys = list(number_word_dict.keys())
    # Проходимся циклом по списку введённых слов
    for word in words:
        # Создаём отфильтрованный список ключей начинающихся с префикса (части слова) с помощью лямбда функции
        # и берем только первый элемент этого списка
        filtered_key = list(filter(lambda x: word.startswith(x), keys))[0]
        
        # Достаём из нашего словаря значение ключа по отфильтрованной переменной
        number = number_word_dict[filtered_key]
        
        # Если временная переменная больше нуля и временная переменная с высоким значением больше 900
        if tmp > 0 and number > 900:
            # Умножаем number и tmp и добавляем в переменную sum
            sum += number * tmp
            # И сразу же обнуляем временную переменную
            tmp = 0
        # Иначе
        else:
            # Во временную переменную добавляем значение number(значение отфильтрованного ключа из словаря)
            tmp += number
    # В итоге возвращаем сложение переменных суммы и временной переменной
    return sum + tmp
# transform_string_to_integer(input_string)

## 5
n = input('Введите число')
def decompose_factorial(n):
    #
    def find_factorial(n):
        n = int(n)
        if n == 0 or n == 1: 
            return 1
        return n * find_factorial(n-1)
    # 
    factor = find_factorial(n)
    return factor
print(decompose_factorial(n))
# Факторизация цисла (простые множители/делители)
def get_prime_factors(N):
    factors = list()
    divisor = 2
    while (divisor <= N):
        if (N % divisor) == 0:
            factors.append(divisor)
            N = N /divisor
        else:
            divisor += 1
    return factors
